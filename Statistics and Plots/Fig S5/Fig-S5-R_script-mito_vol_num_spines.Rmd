---
title: "Fig S5 D, E, G; local mito volume vs local spine size, number of spines around high mito-width regions"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_document:
    theme: darkly
    highlight: breezedark
    df_print: paged
---


```{r setup, include=FALSE}

# Global chunk options: hide messages & warnings everywhere
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```

<hr style="border:1px solid white"/>

**Column Descriptions**

- **cell_id**: cell identifier within MICrONS L2/3 dataset
- **mean_mito_vol**: average (per cell) mitochondrial volume within 1 µm of spine base at the center of the cluster of spines
- **mean_net_cleft**: average (per cell) total spine volume of the cluster of spines
- **spines_high_width**: average number of spines around high width mitochondrial regions
- **spines_low_width**: average number of spines around low width mitochondrial regions 

**Fig S5 D**
```{r}
# === Libraries ===
library(dplyr)
library(readr)
library(ggplot2)
library(ggbeeswarm)
library(rstatix)
library(car)        # for Levene's test
library(ggtext)     # for element_markdown()
library(emmeans)
library(lme4)
library(lmerTest)
library(tidyverse)

# === Read and prepare data ===
mito_df <- read_csv("./mito_vol_num_spines.csv",
  col_types = cols(cell_id = col_character()))
mito_df

# --- Scale data to move decimal points for clear plotting ---
mito_df = mito_df %>% 
  mutate(mean_mito_vol = mean_mito_vol*100,
         mean_net_cleft = mean_net_cleft*1000)

# --- Correlation coefficient ---
cor.test(
  mito_df$mean_net_cleft,
  mito_df$mean_mito_vol,
  method = "pearson"
)

# --- Fit simple linear model on cell means ---
lm_model <- lm(mean_mito_vol ~ mean_net_cleft, data = mito_df)
# --- Build prediction data frame ---
x_seq <- seq(min(mito_df$mean_net_cleft, na.rm = TRUE),
             max(mito_df$mean_net_cleft, na.rm = TRUE),
             length.out = 200)

pred_df <- data.frame(mean_net_cleft = x_seq) %>%
  mutate(
    y_pred = predict(lm_model, newdata = data.frame(mean_net_cleft = x_seq),
                     se.fit = TRUE)$fit,
    se     = predict(lm_model, newdata = data.frame(mean_net_cleft = x_seq),
                     se.fit = TRUE)$se.fit
  ) %>%
  mutate(
    ymin = y_pred - 1.96 * se,
    ymax = y_pred + 1.96 * se
  )

# --- Plot averaged data with regression fit ---
ggplot(mito_df, aes(x = mean_net_cleft, y = mean_mito_vol)) +
  geom_point(size = 4, alpha = 0.8, color = "grey20") +
  geom_ribbon(data = pred_df,
              aes(x = mean_net_cleft, ymin = ymin, ymax = ymax),
              inherit.aes = FALSE,
              alpha = 0.3, fill = "grey60") +
  geom_line(data = pred_df,
            aes(x = mean_net_cleft, y = y_pred),
            inherit.aes = FALSE,
            color = "black", size = 1.5) +
  labs(
    x = "spine size x 10<sup>-3</sup> (&micro;m<sup>2</sup>)",
    y = "local mito volume<br>x 10<sup>-2</sup> (&micro;m<sup>2</sup>)"
  ) +
  scale_y_continuous(
    breaks = c(3, 4, 5, 6, 7),
    expand = c(0, 0),
    limits = c(2.6, 7.5)
  ) +
  scale_x_continuous(
    breaks = c(0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1),
    expand = c(0, 0),
    limits = c(0.48, 1.18)
  ) +
  theme_classic() +
  theme(
    axis.title = element_markdown(),
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.position = "none",
    text = element_text(size = 25, color = "black", face = "bold"),
    axis.text.x = element_text(size = 25, face = "bold", color = "black"),
    axis.text.y = element_text(size = 25, face = "bold", color = "black"),
    axis.ticks = element_line(size = 1, color = "black"),
    axis.line = element_line(size = 0.5, colour = "black")
  )
#

```

<hr style="border:1px solid white"/>

**Fig S5 E**
```{r}
# === Read and prepare data ===
mito_df <- read_csv("./mito_vol_num_spines.csv")

# === Rearrange data to have individual labels for spines_high_width and spines_low_width ===
mito_df <- mito_df %>% dplyr::select(cell_id, spines_high_width, spines_low_width)%>%
  pivot_longer(
    cols = c(spines_high_width, spines_low_width),
    names_to = "spines_type",
    values_to = "mean_n_spines"
  )

# === Normality and test selection ===
if (TRUE) {
  
  # 1. Shapiro-Wilk test for normality per group
  shapiro_results <- mito_df %>%
    group_by(spines_type) %>%
    summarise(
      shapiro_p = shapiro.test(mean_n_spines)$p.value,
      .groups = "drop"
    )
  shapiro_results
  
  # 2. If all groups pass Shapiro -> check variance with Levene
  if (all(shapiro_results$shapiro_p > 0.05)) {
    levene <- leveneTest(mean_n_spines ~ spines_type, data = mito_df, center = median)
    levene
    
    # 3a. Equal variances -> Student’s t-test
    if (levene$`Pr(>F)`[1] > 0.05) {
      stat_res <- t.test(mean_n_spines ~ spines_type, data = mito_df, var.equal = TRUE)
      test_used <- "Student's t-test"
      
    # 3b. Unequal variances -> Welch’s t-test
    } else {
      stat_res <- t.test(mean_n_spines ~ spines_type, data = mito_df, var.equal = FALSE)
      test_used <- "Welch's t-test"
    }
    
  # 4. If any group fails Shapiro -> Wilcoxon rank-sum
  } else {
    stat_res <- wilcox.test(mean_n_spines ~ spines_type, data = mito_df, exact = FALSE)
    test_used <- "Wilcoxon rank-sum test"
  }
  
  # Output
  test_used
  stat_res
}


# === Prepare data for plotting ===
spacing_map <- c("spines_low_width" = 1, "spines_high_width" = 2.2)
mito_df <- mito_df %>%
  filter(spines_type %in% names(spacing_map)) %>%
  mutate(
    x_pos = spacing_map[spines_type],
    spines_type = factor(spines_type, levels = c("spines_low_width", "spines_high_width"))
  )

# === Build annotation (stars) ===
pval <- stat_res$p.value
p.signif <- case_when(
  pval < 0.0001 ~ "****",
  pval < 0.001  ~ "***",
  pval < 0.01   ~ "**",
  pval < 0.05   ~ "*",
  TRUE          ~ "ns"
)

test_results <- tibble(
  group1_x = spacing_map["spines_low_width"],
  group2_x = spacing_map["spines_high_width"],
  y.position = 6,
  p.signif = p.signif
)

# === Final plot ===
ggplot(mito_df, aes(x = x_pos, y = mean_n_spines, color = spines_type)) +
  geom_beeswarm(cex = 3, priority = "random", size = 3, alpha = 0.8, corral = "random") +
  geom_boxplot(aes(group = x_pos), fill = NA, width = 1,
               outlier.shape = NA, size = 0.75, color = "black") +
  stat_summary(fun = mean, geom = "point", shape = 15, size = 5, color = "black") +
  geom_segment(data = test_results,
               aes(x = group1_x, xend = group2_x, y = y.position, yend = y.position),
               inherit.aes = FALSE, size = 1, color = "black") +
  geom_text(data = test_results,
            aes(x = (group1_x + group2_x)/2, y = y.position + 0.05, label = p.signif),
            inherit.aes = FALSE, size = 16, fontface = "bold") +
  scale_x_continuous(breaks = c(1, 2.2),
                     labels = c("low-width\nmitochondrial regions", "high-width\nmitochondrial regions")) +
  scale_color_manual(values = c("grey20", "grey20")) +
  scale_y_continuous(
    breaks = c(2, 3, 4, 5, 6),
    expand = c(0, 0),
    limits = c(1.5, 6.5)
  ) +
  labs(x = "", y = "number of spines") +
  theme_classic() +
  theme(
    axis.title.y = element_markdown(),
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.position = "none",
    text = element_text(size = 20, color = "black", face = "bold"),
    axis.text.x = element_text(size = 20, face = "bold", color = "black"),
    axis.text.y = element_text(size = 25, face = "bold", color = "black"),
    axis.ticks = element_line(size = 1, color = "black"),
    axis.line = element_line(size = 0.5, colour = "black")
  )

```
<hr style="border:1px solid white"/>

**Column Descriptions**

- **cell_id**: cell identifier  
- **mean_net_cleft**: average (per cell) total spine volume of the cluster of spines
- **spines_high_width**: average number of spines around high width mitochondrial regions
- **spines_low_width**: average number of spines around low width mitochondrial regions 

**Fig S5 G (same neurons as Fig 1 control)**
```{r}
# === Read and prepare data ===
mito_df <- read_csv("./confocal_num_spines.csv")
mito_df

# === Rearrange data to have individual labels for spines_high_width and spines_low_width ===
mito_df <- mito_df %>% dplyr::select(cell_id, spines_high_width, spines_low_width)%>%
  pivot_longer(
    cols = c(spines_high_width, spines_low_width),
    names_to = "spines_type",
    values_to = "mean_n_spines"
  )

# === Normality and test selection ===
if (TRUE) {
  
  # 1. Shapiro-Wilk test for normality per group
  shapiro_results <- mito_df %>%
    group_by(spines_type) %>%
    summarise(
      shapiro_p = shapiro.test(mean_n_spines)$p.value,
      .groups = "drop"
    )
  shapiro_results
  
  # 2. If all groups pass Shapiro -> check variance with Levene
  if (all(shapiro_results$shapiro_p > 0.05)) {
    levene <- leveneTest(mean_n_spines ~ spines_type, data = mito_df, center = median)
    levene
    
    # 3a. Equal variances -> Student’s t-test
    if (levene$`Pr(>F)`[1] > 0.05) {
      stat_res <- t.test(mean_n_spines ~ spines_type, data = mito_df, var.equal = TRUE)
      test_used <- "Student's t-test"
      
    # 3b. Unequal variances -> Welch’s t-test
    } else {
      stat_res <- t.test(mean_n_spines ~ spines_type, data = mito_df, var.equal = FALSE)
      test_used <- "Welch's t-test"
    }
    
  # 4. If any group fails Shapiro -> Wilcoxon rank-sum
  } else {
    stat_res <- wilcox.test(mean_n_spines ~ spines_type, data = mito_df, exact = FALSE)
    test_used <- "Wilcoxon rank-sum test"
  }
  
  # Output
  test_used
  stat_res
}


# === Prepare data for plotting ===
spacing_map <- c("spines_low_width" = 1, "spines_high_width" = 2.2)
mito_df <- mito_df %>%
  filter(spines_type %in% names(spacing_map)) %>%
  mutate(
    x_pos = spacing_map[spines_type],
    spines_type = factor(spines_type, levels = c("spines_low_width", "spines_high_width"))
  )

# === Build annotation (stars) ===
pval <- stat_res$p.value
p.signif <- case_when(
  pval < 0.0001 ~ "****",
  pval < 0.001  ~ "***",
  pval < 0.01   ~ "**",
  pval < 0.05   ~ "*",
  TRUE          ~ "ns"
)

test_results <- tibble(
  group1_x = spacing_map["spines_low_width"],
  group2_x = spacing_map["spines_high_width"],
  y.position = 2.22,
  p.signif = p.signif
)

# === Final plot ===
ggplot(mito_df, aes(x = x_pos, y = mean_n_spines, color = spines_type)) +
  geom_beeswarm(cex = 3, priority = "random", size = 3, alpha = 0.8, corral = "random") +
  geom_boxplot(aes(group = x_pos), fill = NA, width = 1,
               outlier.shape = NA, size = 0.75, color = "black") +
  stat_summary(fun = mean, geom = "point", shape = 15, size = 5, color = "black") +
  geom_segment(data = test_results,
               aes(x = group1_x, xend = group2_x, y = y.position, yend = y.position),
               inherit.aes = FALSE, size = 1, color = "black") +
  geom_text(data = test_results,
            aes(x = (group1_x + group2_x)/2, y = y.position + 0.05, label = p.signif),
            inherit.aes = FALSE, size = 16, fontface = "bold") +
  scale_x_continuous(breaks = c(1, 2.2),
                     labels = c("low-width\nmitochondrial regions", "high-width\nmitochondrial regions")) +
  scale_color_manual(values = c("grey20", "grey20")) +
  scale_y_continuous(
    breaks = c(1.2, 1.6, 2.0),
    expand = c(0, 0),
    limits = c(1.1, 2.38)
  ) +
  labs(x = "", y = "number of spines") +
  theme_classic() +
  theme(
    axis.title.y = element_markdown(),
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.position = "none",
    text = element_text(size = 20, color = "black", face = "bold"),
    axis.text.x = element_text(size = 20, face = "bold", color = "black"),
    axis.text.y = element_text(size = 25, face = "bold", color = "black"),
    axis.ticks = element_line(size = 1, color = "black"),
    axis.line = element_line(size = 0.5, colour = "black")
  )

```