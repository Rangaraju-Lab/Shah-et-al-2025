---
title: "Fig 7 E, G, H; ATP<sub>mito</sub> and ATP<sub>spine</sub>"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_document:
    theme: darkly
    highlight: breezedark
    df_print: paged
---


```{r setup, include=FALSE}

# Global chunk options: hide messages & warnings everywhere
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  echo = TRUE
)
```
<hr style="border:1px solid white"/>

**Fig 7 E**

**Column Descriptions**

- **Date**: date of imaging or experiment (format: YYYY-MM-DD)
- **Condition**: experimental condition (e.g., *Control*, *TTX*)  
- **Cell**: cell identifier within the Condition 
- **L**: luminescence intensity of mito roi  
- **F**: fluorescence intensity of mito roi
- **LbyF**: luminescence normalized by fluorescence  

```{r}
# === Libraries ===
library(dplyr)
library(readr)
library(ggplot2)
library(ggbeeswarm)
library(rstatix)
library(car)        # for Levene's test
library(ggtext)     # for element_markdown()

# === Load data (without Dish) ===
LbyF_df <- read_csv("./Mito LbyF.csv")
LbyF_df %>% arrange(Date, Condition, Cell)

# === Animals per condition (check) ===
LbyF_df %>%
  distinct(Date, Condition) %>%
  count(Condition, name = "n_animal")
# === Cells per condition (check) ===
LbyF_df %>%
  distinct(Date, Condition, Cell) %>%
  count(Condition, name = "n_cell")
# === Spines per condition (check) ===
LbyF_df %>%
  count(Condition, name = "n_mito")

# === Normality and test selection ===
if (TRUE) {
  
  # 1. Shapiro-Wilk test for normality per group
  shapiro_results <- LbyF_df %>%
    group_by(Condition) %>%
    summarise(
      shapiro_p = shapiro.test(LbyF)$p.value,
      .groups = "drop"
    )
  shapiro_results
  
  # 2. If all groups pass Shapiro -> check variance with Levene
  if (all(shapiro_results$shapiro_p > 0.05)) {
    levene <- leveneTest(LbyF ~ Condition, data = LbyF_df, center = median)
    levene
    
    # 3a. Equal variances -> Student’s t-test
    if (levene$`Pr(>F)`[1] > 0.05) {
      stat_res <- t.test(LbyF ~ Condition, data = LbyF_df, var.equal = TRUE)
      test_used <- "Student's t-test"
      
    # 3b. Unequal variances -> Welch’s t-test
    } else {
      stat_res <- t.test(LbyF ~ Condition, data = LbyF_df, var.equal = FALSE)
      test_used <- "Welch's t-test"
    }
    
  # 4. If any group fails Shapiro -> Wilcoxon rank-sum
  } else {
    stat_res <- wilcox.test(LbyF ~ Condition, data = LbyF_df, exact = FALSE)
    test_used <- "Wilcoxon rank-sum test"
  }
  
  # Output
  test_used
  stat_res
}

# === Prepare data for plotting ===
spacing_map <- c("Control" = 1, "TTX" = 2.2)
LbyF_df <- LbyF_df %>%
  filter(Condition %in% names(spacing_map)) %>%
  mutate(
    x_pos = spacing_map[Condition],
    Condition = factor(Condition, levels = c("Control", "TTX"))
  )

# === Build annotation (stars) ===
pval <- stat_res$p.value
p.signif <- case_when(
  pval < 0.0001 ~ "****",
  pval < 0.001  ~ "***",
  pval < 0.01   ~ "**",
  pval < 0.05   ~ "*",
  TRUE          ~ "ns"
)

test_results <- tibble(
  group1_x = spacing_map["Control"],
  group2_x = spacing_map["TTX"],
  y.position = 0.21,
  p.signif = p.signif
)

# === Final plot ===
ggplot(LbyF_df, aes(x = x_pos, y = LbyF, color = Condition)) +
  geom_boxplot(aes(group = x_pos), fill = NA, width = 1,
               outlier.shape = NA, size = 0.75, color = "black") +
  geom_beeswarm(cex = 3, priority = "random", size = 3, alpha = 0.8, corral = "random") +
  stat_summary(fun = mean, geom = "point", shape = 15, size = 5, color = "black") +
  geom_segment(data = test_results,
               aes(x = group1_x, xend = group2_x, y = y.position, yend = y.position),
               inherit.aes = FALSE, size = 1, color = "black") +
  geom_text(data = test_results,
            aes(x = (group1_x + group2_x)/2, y = y.position + 0.005, label = p.signif),
            inherit.aes = FALSE, size = 16, fontface = "bold") +
  scale_x_continuous(breaks = c(1, 2.2),
                     labels = c("control", "homeostatic\nscaling")) +
  scale_color_manual(values = c("grey20", "#8A00CB")) +
  scale_y_continuous(
    breaks = c(0, 0.1, 0.2),
    expand = c(0, 0)
  ) +
  coord_cartesian(ylim = c(0, 0.23)) +
  labs(x = "", y = "ATP<sub>mito</sub> (L/F)") +
  theme_classic() +
  theme(
    axis.title.y = element_markdown(),
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.position = "none",
    text = element_text(size = 35, color = "black", face = "bold"),
    axis.text.x = element_text(size = 35, face = "bold", color = "black"),
    axis.text.y = element_text(size = 30, face = "bold", color = "black"),
    axis.ticks = element_line(size = 1, color = "black"),
    axis.line = element_line(size = 0.5, colour = "black")
  )

```

<hr style="border:1px solid white"/>

**Fig 7 G**

**Column Descriptions**

- **Date**: Date of imaging or experiment (format: YYYY-MM-DD)  
- **Condition**: Experimental condition (*Control*, *TTX*)  
- **Dish**: Dish or coverslip identifier (used for batch tracking)  
- **Cell**: Cell identifier within the dish  
- **L**: Luminescence intensity of spine  
- **F**: Fluorescence intensity of spine  
- **LbyF**: Luminescence normalized by Fluorescence  
- **mito_area**: area of mitochondria in µm² within 1 µm radius under spine
- **date_id**: numerical identifier for Date used in mixed effect model
- **nested_cell_id**: numerical identifier for Cell starting from 1 within each date_id used in mixed effect model 


```{r}
# === Libraries ===
library(dplyr)
library(readr)
library(ggplot2)
library(ggbeeswarm)
library(rstatix)
library(car)        # for Levene's test
library(ggtext)     # for element_markdown()
library(emmeans)
library(lme4)
library(lmerTest)

# === Load data (without Dish) ===
LbyF_df <- read_csv("./Spine LbyF.csv")%>% 
  filter(Condition %in% c("Control", "TTX"))
LbyF_df%>% arrange(Date, Condition, Cell)
# === Animals per condition (check) ===
LbyF_df %>%
  distinct(Date, Condition) %>%
  count(Condition, name = "n_animal")
# === Cells per condition (check) ===
LbyF_df %>%
  distinct(Date, Condition, Dish, Cell) %>%
  count(Condition, name = "n_cell")
# === Spines per condition (check) ===
LbyF_df %>%
  count(Condition, name = "n_spines")

# === Normality and test selection ===
if (TRUE) {
  
  # 1. Shapiro-Wilk test for normality per group
  shapiro_results <- LbyF_df %>%
    group_by(Condition) %>%
    summarise(
      shapiro_p = shapiro.test(LbyF)$p.value,
      .groups = "drop"
    )
  shapiro_results
  
  # 2. If all groups pass Shapiro -> check variance with Levene
  if (all(shapiro_results$shapiro_p > 0.05)) {
    levene <- leveneTest(LbyF ~ Condition, data = LbyF_df, center = median)
    levene
    
    # 3a. Equal variances -> Student’s t-test
    if (levene$`Pr(>F)`[1] > 0.05) {
      stat_res <- t.test(LbyF ~ Condition, data = LbyF_df, var.equal = TRUE)
      test_used <- "Student's t-test"
      
    # 3b. Unequal variances -> Welch’s t-test
    } else {
      stat_res <- t.test(LbyF ~ Condition, data = LbyF_df, var.equal = FALSE)
      test_used <- "Welch's t-test"
    }
    
  # 4. If any group fails Shapiro -> Wilcoxon rank-sum
  } else {
    stat_res <- wilcox.test(LbyF ~ Condition, data = LbyF_df, exact = FALSE)
    test_used <- "Wilcoxon rank-sum test"
  }
  
  # Output
  test_used
  stat_res
}


# === Prepare data for plotting ===
spacing_map <- c("Control" = 1, "TTX" = 2.2)
LbyF_df <- LbyF_df %>%
  filter(Condition %in% names(spacing_map)) %>%
  mutate(
    x_pos = spacing_map[Condition],
    Condition = factor(Condition, levels = c("Control", "TTX"))
  )

# === Build annotation (stars) ===
pval <- stat_res$p.value
p.signif <- case_when(
  pval < 0.0001 ~ "****",
  pval < 0.001  ~ "***",
  pval < 0.01   ~ "**",
  pval < 0.05   ~ "*",
  TRUE          ~ "ns"
)

test_results <- tibble(
  group1_x = spacing_map["Control"],
  group2_x = spacing_map["TTX"],
  y.position = 0.7,
  p.signif = p.signif
)

# === Final plot ===
ggplot(LbyF_df, aes(x = x_pos, y = LbyF, color = Condition)) +
  geom_boxplot(aes(group = x_pos), fill = NA, width = 1,
               outlier.shape = NA, size = 0.75, color = "black") +
  geom_beeswarm(cex = 3, priority = "random", size = 3, alpha = 0.8, corral = "random") +
  stat_summary(fun = mean, geom = "point", shape = 15, size = 5, color = "black") +
  geom_segment(data = test_results,
               aes(x = group1_x, xend = group2_x, y = y.position, yend = y.position),
               inherit.aes = FALSE, size = 1, color = "black") +
  geom_text(data = test_results,
            aes(x = (group1_x + group2_x)/2, y = y.position + 0.005, label = p.signif),
            inherit.aes = FALSE, size = 16, fontface = "bold") +
  scale_x_continuous(breaks = c(1, 2.2),
                     labels = c("control", "homeostatic\nscaling")) +
  scale_color_manual(values = c("grey20", "#8A00CB")) +
  scale_y_continuous(
    breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4),
    expand = c(0, 0)
  ) +
  coord_cartesian(ylim = c(0, 0.75)) +
  labs(x = "", y = "ATP<sub>spine</sub> (L/F)") +
  theme_classic() +
  theme(
    axis.title.y = element_markdown(),
    panel.grid = element_blank(),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.position = "none",
    text = element_text(size = 30, color = "black", face = "bold"),
    axis.text.x = element_text(size = 30, face = "bold", color = "black"),
    axis.text.y = element_text(size = 30, face = "bold", color = "black"),
    axis.ticks = element_line(size = 1, color = "black"),
    axis.line = element_line(size = 0.5, colour = "black")
  )

```

<hr style="border:1px solid white"/>

**Fig 7 H**

ATP<sub>spine</sub> vs local mito area linear mixed model
```{r}
# === Fit linear mixed model ===
# Model: ATP_spine (L/F) ~ local mito area × Condition
# Random effects: random intercepts for Date, nested Cell IDs
lmer_model <- lmer(
  LbyF ~ mito_area * Condition + (1 | date_id/cell_id_nested),
  data = LbyF_df
)

# Summarize fixed effects and variance-covariance matrix
summary(lmer_model)
coefs <- fixef(lmer_model)
vcov_mat <- as.matrix(vcov(lmer_model))


# === Build prediction grid ===
# Sequence of mito_area values across observed range
x_seq <- seq(
  min(LbyF_df$mito_area, na.rm = TRUE),
  max(LbyF_df$mito_area, na.rm = TRUE),
  length.out = 200
)


# === Delta method confidence intervals ===
# Function to compute model prediction and 95% CI
# separately for Control and TTX conditions
get_pred_ci <- function(condition, x) {
  if (condition == "Control") {
    mu <- coefs["(Intercept)"] + coefs["mito_area"] * x
    b <- c(1, x, 0, 0)
  } else if (condition == "TTX") {
    mu <- coefs["(Intercept)"] + coefs["ConditionTTX"] +
          (coefs["mito_area"] + coefs["mito_area:ConditionTTX"]) * x
    b <- c(1, x, 1, x)
  }
  se <- sqrt(as.numeric(t(b) %*% vcov_mat %*% b))
  data.frame(
    Condition = condition,
    mito_area = x,
    LbyF_pred = mu,
    ymin = mu - 1.96 * se,
    ymax = mu + 1.96 * se
  )
}

# Generate predictions for both conditions
pred_Control <- do.call(rbind, lapply(x_seq, function(x) get_pred_ci("Control", x)))
pred_TTX     <- do.call(rbind, lapply(x_seq, function(x) get_pred_ci("TTX", x)))
model_pred   <- rbind(pred_Control, pred_TTX)


# === Means for reference lines ===
# (optional summary of average mito_area and L/F per condition)
means <- LbyF_df %>%
  group_by(Condition) %>%
  summarise(
    mean_mito = mean(mito_area, na.rm = TRUE),
    mean_LbyF = mean(LbyF, na.rm = TRUE)
  )


# === Plotting ===
# Scatter points: raw data
# Ribbons: 95% CI bands
# Lines: fitted regression lines
max_x   <- max(LbyF_df$mito_area, na.rm = TRUE)
max_y   <- max(LbyF_df$LbyF, na.rm = TRUE)
y_upper <- max_y * 1.05

ggplot(LbyF_df, aes(x = mito_area, y = LbyF)) +
  geom_point(aes(color = Condition), alpha = 0.8, size = 3) +
  geom_ribbon(
    data = model_pred,
    aes(x = mito_area, ymin = ymin, ymax = ymax, fill = Condition),
    inherit.aes = FALSE, alpha = 0.25
  ) +
  geom_line(
    data = model_pred,
    aes(x = mito_area, y = LbyF_pred, group = Condition),
    color = "black",
    size = 2
  ) +
  scale_color_manual(values = c("Control" = "grey20", "TTX" = "#8A00CB")) +
  scale_fill_manual(values = c("Control" = "grey20", "TTX" = "#8A00CB")) +
  labs(
    x = "local mito area (µm²)\n",
    y = "ATP<sub>spine</sub> (L/F)"
  ) +
  theme_classic() +
  theme(
    axis.title.y    = element_markdown(),
    panel.grid      = element_blank(),
    panel.background= element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.position = "none",
    text            = element_text(size = 30, color = "black", face = "bold"),
    axis.text.x     = element_text(size = 30, face = "bold", color = "black"),
    axis.text.y     = element_text(size = 30, face = "bold", color = "black"),
    axis.ticks      = element_line(size = 2, color = "black"),
    axis.line       = element_line(size = 0.5, colour = "black"),
    strip.background= element_blank(),
    strip.text      = element_text(size = 30, face = "bold", color = "black"),
    panel.spacing   = unit(0.5, "in")
  ) +
  scale_y_continuous(
    breaks = c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2),
    limits = c(0, 0.7),
    expand = c(0, 0)
  ) +
  scale_x_continuous(
    limits = c(0, max_x*1.05),
    expand = c(0, 0)
  )


# === Test slope ===
test(emtrends(lmer_model, ~ Condition, var = "mito_area"))

```

